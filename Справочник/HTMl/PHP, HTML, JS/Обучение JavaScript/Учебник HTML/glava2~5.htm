<html><head>






<title> Примеры манипулирования окнами</title>
		    <style type="text/css">
A.noneline { font-family: Arial, Serif; text-decoration: none; }
FONT.arial { font-family: Arial, Serif; }
TD.arial   { font-family: Arial, Serif; }
TH.arial   { font-family: Arial, Serif; }
PRE        { font-family: Monospace; color: navy; }
SAMP       { font-family: Monospace; color: navy; }
TT         { font-family: Monospace; color: navy; }
VAR        { font-family: Monospace; color: navy; }
</style>
</head>
<body bgcolor="#FFF5EE" text="#000000" link="#FF0000" alink="#FF0000" vlink="#A52A2A">
<basefont size="3">
<center>
<table width=100% border=0 cellpadding=0>
<tr valign=top><td class=arial><a href="http://www.citforum.ru/"><img height=50 width=150 src="_pic_/logo3D.gif" alt="Server for Information Technologies" border=0></a><br>
</td>
<td align=right class=arial>
<font size="-2">
Сервер поддерживается<br>
<a class=noneline href="http://www.citmgu.ru">Центром Информационных Технологий</a><br>
(095) 932-9212, 932-9213, 939-0783<br>
E-mail: <a class=noneline href="mailto:info@citforum.ru?Subject='From page topic CIT-FORUM'">info@citforum.ru</a></font>
</tr>
<tr>
<th colspan=2 class=arial>
<font color=#000080 size=2><a href="http://www.citforum.ru" class=noneline>Сервер Информационных Технологий</a> содержит море(!) аналитической информации</font>
<hr noshade>
</th>
</tr>
</table>
</center>

<h4>2.14. Примеры манипулирования окнами</h4>
<P ALIGN="JUSTIFY">Как это не покажется странным, но в наших простых примерах мы уже начали манипулировать окнами. Открытие окна-пердупреждения - это операция над объектом "окно". Определим свойства объекта "окно", методы изменения этих свойств и события, которые могут быть связаны с объектом типа "окно". При этом мы не ставим перед собой задачи описания всех известных в JavaScript свойств, методов и событий, связанных с объектами этого класса. Определим только те, которые понадобятся в наших примерах.
<h4><i>Методы</i></h4>
<P ALIGN="JUSTIFY">Методы позволяют нам создать на экране видимое окно, закрыть окно и проделать с ним другие операции. С методом window.alert мы уже знакомы. Методы window.confirm и window.prompt используются для получения ответов от пользователя:
<i><P ALIGN="JUSTIFY">Пример 2.16.</i> Использование методов Alert, Prompt, Confirm
<pre>
	&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;title&gt;Window simple example&lt;/title&gt;
	&lt;/HEAD&gt;
	&lt;BODY&gt;
	&lt;center&gt;
	&lt;h1&gt;Simple window methods&lt;/h1&gt;
	&lt;hr&gt;
	&lt;/center&gt;
	&lt;ul&gt;
	&lt;li&gt;&lt;a href="javascript:window.alert('Attention!!! press the button to continue.')"&gt;Метод Alert.&lt;/a&gt;
	&lt;li&gt;&lt;a href="javascript:window.status=window.confirm('Answer yes or no.');void(0);"&gt;Метод Confirm.&lt;/a&gt;
	&lt;li&gt;&lt;a href="javascript:window.status=window.prompt('Type string here:','');void(0);"&gt;Метод Prompt.&lt;/a&gt;
	&lt;/ul&gt;
	&lt;/BODY&gt;
	&lt;/HTML&gt;</Pre>
<P ALIGN="JUSTIFY">В данном примере при вызове метода confirm появляется окно с просьбой подтверждения некоторого действия, при использовании метода prompt - окно с приглашением ввести информацию в поле ввода. В двух последних случаях если не указать функции void(0), произойдет замещение текста HTML-документа на значение, которое возвращают эти два метода. Если внимательно смотреть за полем окна навигатора, в котором отображается информация о загрузке документов, то там можно будет увидеть возвращаемые значения, т.к. они присваиваются свойству status текущего окна, которое связано именно с этим полем, и которому можно присваивать значения, и, следовательно, эти значения будут отображаться в этом поле.
<P ALIGN="JUSTIFY">Однако, следует признать, что рассмотренные выше методы используются крайне редко. А тем более в приведенном здесь контексте, поэтому поспешим рассмотреть методы открытия и закрытия окна.
<P ALIGN="JUSTIFY">Открыть окно можно используя метод open:
<i><P ALIGN="JUSTIFY">Пример 2.17.</i> Метод window.open
<pre>
	&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;title&gt;Window simple example&lt;/title&gt;
	&lt;/HEAD&gt;
	&lt;BODY&gt;
	&lt;center&gt;
	&lt;h1&gt;Open window methods&lt;/h1&gt;
	&lt;hr&gt;
	&lt;/center&gt;
	Если выбрать гипертекстовую ссылку
	&lt;a href="javascript:window.open('simple8.htm','example','scrollbars,
	resizable,width=300,height=200');void(0);"&gt;Открыть окно&lt;/a&gt;, то 
	будет открыто новое окно. Чаще всего этот прием используют
	при создании контекстно зависимых меню.
	&lt;/BODY&gt;
	&lt;/HTML&gt;</Pre>
<P ALIGN="JUSTIFY">В данном случае при выборе гипертекстовой ссылки будет открыто окно шириной 300 пикселей и высотой 200 пикселей, в окне не будет никаких стандартных меню навигатора, и в окно будет загружен документ simple8.html. Метод open позволяет также определить области прокрутки, наличие или отсутствие стандартных меню навигатора и возможность изменения размеров окна. Последняя возможность зависит от платформы на которой исполняется скрипт.
<P ALIGN="JUSTIFY">Документ simple8.htm в свою очередь содержит код, который позволяет закрыть окно, открытое в примере 2.17:
<i><P ALIGN="JUSTIFY">Пример 2.18.</i> Закрыть текущее окно
<pre>
	&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;title&gt;Window simple example&lt;/title&gt;
	&lt;/HEAD&gt;
	&lt;BODY&gt;
	&lt;center&gt;
	&lt;h1&gt;Close window methods&lt;/h1&gt;
	&lt;hr&gt;
	&lt;/center&gt;
	Если выбрать гипертекстовую ссылку 
	&lt;a href="javascript:window.close();void(0);"&gt;
	Закрыть окно&lt;/a&gt;, то 
	данное окно будет закрыто.
	&lt;/BODY&gt;
	&lt;/HTML&gt;</Pre>
<P ALIGN="JUSTIFY">В данном примере в качестве гипертекстовой ссылки используется ссылка на метод widow.close(), который закрывает текущее окно. На применении методов open и close построен принцип построения help. По методу open открывается окно подсказки. В него загружают текст документа-подсказки с заранее заготовленной ссылкой на закрытие окна. При выборе этой ссылки окно подсказки закрывается, и пользователь продолжает работать с основным окном навигатора.
<P ALIGN="JUSTIFY">Рассмотрим еще один метод, связанный с окном - метод scroll. Данный метод позволяет организовать прокрутку текста в окне.
<i><P ALIGN="JUSTIFY">Пример 2.19.</i> Прокрутка текста в окне навигатора
<pre>
	&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;title&gt;Scroll text&lt;/title&gt;
	&lt;/HEAD&gt;
	&lt;BODY&gt;
	&lt;center&gt;
	&lt;h1&gt;Прокрутка текста в окне навигатора&lt;/h1&gt;
	&lt;hr&gt;
	[&lt;a href="javascript:for(i=0;i&lt;80;i++)
	{window.scroll(0,i*10)};void(0);"&gt;Прокрутить текст&lt;/a&gt;]
	&lt;hr&gt;
	&lt;/center&gt;
	Вообще говоря, проверить тип программы просмотра можно на сервере
	протокола HTTP и передать программе просмотра уже готовую страницу 
	без условной генерации ее
	...
	&nbsp;
	&lt;hr&gt;
	&lt;center&gt;[&lt;a href=#top&gt;Вернуться в начало&lt;/a&gt;]&lt;/center&gt;
	&lt;/BODY&gt;
	&lt;/HTML&gt;</Pre>
<P ALIGN="JUSTIFY">От метода прокрутки мы перейдем теперь к методу, который позволит нам прокручивать документ более равномерно - это метод setTimeout. Большинству пользователей Web он знаком по бегущим строкам в поле статуса программы-навигатора. Метод setTimeout позволяет отложить выполнение функции, которая указывается в качестве аргумента на определенное количество миллисекунд. Системы прокрутки в этом случае рекурсивно вызывают свое выполнение через этот метод и тем самым порождают бесконечный цикл прокрутки.
<i><P ALIGN="JUSTIFY">Пример 2.20. </i>Прокрутка текста по таймеру
<pre>
	&lt;HTML&gt;
	&lt;HEAD&gt;
	&lt;title&gt;Scroll text&lt;/title&gt;
	&lt;script language=JavaScript&gt;
	&lt;!-- 
	i=0;flag=0;start_stop=0;
	function my_scroll()
	         {
	          if(start_stop==1)
	            {
	             window.scroll(0,i*10);
	             if(flag==0) i++;
	             if(flag==1) i--;
	             if(i&gt;80) {i=80;flag=1;}
	             if(i&lt;0) {i=0;flag=0;}
	            }
	          setTimeout("my_scroll()",500);
	         }
	function kuku()
	         {
	          if(start_stop == 0) 
	            {
	             start_stop =1;
	            }
	          else
	            {
	             start_stop =0;
	            }
	         }
	// --&gt;
	&lt;/script&gt;
	&lt;/HEAD&gt;
	&lt;BODY onLoad=my_scroll()&gt;
	&lt;center&gt;
	&lt;h1&gt;Прокрутка текста в окне навигатора&lt;/h1&gt;
	&lt;hr&gt;
	[&lt;a href="javascript:kuku();void(0);"&gt;Запустить/Остановить&lt;/a&gt;]
	&lt;hr&gt;
	&lt;/center&gt;
	Вообще говоря, проверить тип программы просмотра можно на сервере
	протокола HTTP и передать программе просмотра уже готовую страницу 
	без условной генерации ее
	...
	&lt;hr&gt;
	&lt;center&gt;[&lt;a href=#top&gt;Вернуться в начало&lt;/a&gt;]&lt;/center&gt;
	&lt;/BODY&gt;
	&lt;/HTML&gt;</Pre>
<P ALIGN="JUSTIFY">В данном примере мы не стали писать текст программ в самих гипертекстовых ссылках и вынесли его в заголовок документа. В данном случае это облегчает чтение текста и отладку программы. Текст прокручивается через каждые 500 миллисекунд, что делает прокрутку более плавной. В примере мы впервые применили событие onLoad. Это событие запускает процесс выполнения нашей функции. Прокрутка текста осуществляется в двух направлениях: сначала снизу вверх, а по достижении конца документа сверху вниз.
<P ALIGN="JUSTIFY">Следует подробно остановиться на особенностях исполнения метода setTimeout. Особенно в части запуска и останова процедуры прокрутки. Рассматривать алгоритм ее исполнения лучше всего в контексте многопоточных или многозадачных систем. Функция my_scroll - это отдельный процесс (поток), который исполняется программой-навигатором. В момент, когда интерпретатор навигатора встречает метод setTimeout, он создает новый процесс (поток), эквивалентный функции my_scroll, и откладывает его исполнение на 500 миллисекунд. После этого он продолжает выполнять текущий процесс (поток). В нашем случае вызов метода setTimeout - это последняя команда функции my_scroll, поэтому после нее ничего не выполняется, а сам процесс или поток, связанный с текущей функцией my_scroll после обработки setTimeout уничтожается. Однако, новый процесс (поток) уже создан в памяти и ждет начала своего исполнения.
<P ALIGN="JUSTIFY">В нашем примере новый процесс поток порождается всякий раз, как интерпретатор достигает метода setTimeout, а уничтожается, когда интерпретатор доходит до последнего оператора этого потока. Такой алгоритм выполнения заставляет расположить вызов setTimeout за пределами блока проверки условий скроллинга. Если мы расположим его внутри, то при останове скроллинга новый процесс не будет порожден, а это значит, что и кода, который будет реагировать на флаг скроллинга после останова, не будет существовать, т.е. запустить скроллинг не будет никакой возможности. Именно по этой причине функция my_scroll начинает исполняться сразу после загрузки документа по событию onLoad, но т.к. флаг скроллинга 0, то прокрутки текста не происходит. Процесс порождается все время, пока страница загружена в текущее окно навигатора.
<P ALIGN="JUSTIFY">Во второй версии навигатора данная функция была реализована не очень аккуратно, что приводило к переполнению программного стека и краху программы-навигатора.
<p><center><p>
<font size=-1>
<a href="glava2~4.htm">Назад</a> | <a href="index.htm">Содержание</a> | <a href="glava2~6.htm">Вперед</a></font></center></p>
</p>
<hr noshade>
<center>
<font size=1 class=arial>
Comments: <a href="mailto:info@citmgu.ru?Subject='From bottom of CIT FORUM'" class=noneline>info@citmgu.ru</a><br>
Copyright &copy; <a href="http://www.citmgu.ru/" class=noneline>CIT</a>
</font></center></body></html>
